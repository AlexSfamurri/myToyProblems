 /*! toyproblems v0.0.0 - MIT license */
'use strict';
/*
  * Basic tree that stores a value.
*/

const Tree = function (value) {
  this.value = value;
  this.children = [];
};

Tree.prototype.map = function (callback) {
  // TODO: return a new tree with the same structure as `this`, with values generated by the callback
  //for keeping things straight and just to make sure the this binding does not get lost
  const oldTree = this;
  //need to start the new tree
  const newTree = new Tree(callback(oldTree.value));

  //internal recursive function to do a dfs so as to properly put things in there place
  const diver = (node, newNode) => {
    //goes through each child of the node
    node.children.forEach((child, index) => {
      // grabs the value that is returned by the callback
      const cbValue = callback(child.value);
      //creates a child with this new value
      newNode.addChild(cbValue);
      //if this child has children of its own
      if (child.children.length){
        //we recurse pasing the child and the newchild
        console.log(newNode);
        
        diver(child, newNode.children[index]);
      }

    });
  };

  diver(oldTree, newTree)

  return newTree;
};


Tree.prototype.mapInPlace = function (callback) {
  // TODO: update the values of the existing tree with values generated by the callback
  const node = this;

  const queue = [];
  queue.push(node);

  while(queue.length > 0) {
    const shifted = queue.shift();
    shifted.value = callback(shifted.value);
    shifted.children.forEach(child => {
      queue.push(child);
    })
  }

};

/**
 * You shouldn't need to change anything below here, but feel free to look.
  */

/**
  * add an immediate child
  * (wrap values in Tree nodes if they're not already)
  */
Tree.prototype.addChild = function (child) {
  if (!child || !(child instanceof Tree)) {
    child = new Tree(child);
  }

  if (!this.isDescendant(child)) {
    this.children.push(child);
  } else {
    throw new Error("That child is already a child of this tree");
  }
  // return the new child node for convenience
  return child;
};

/**
  * check to see if the provided tree is already a child of this
  * tree __or any of its sub trees__
  */
Tree.prototype.isDescendant = function (child) {
  if (this.children.indexOf(child) !== -1) {
    // `child` is an immediate child of this tree
    return true;
  } else {
    for (var i = 0; i < this.children.length; i++) {
      if (this.children[i].isDescendant(child)) {
        // `child` is descendant of this tree
        return true;
      }
    }
    return false;
  }
};

/**
  * remove an immediate child
  */
Tree.prototype.removeChild = function (child) {
  var index = this.children.indexOf(child);
  if (index !== -1) {
    // remove the child
    this.children.splice(index, 1);
  } else {
    throw new Error("That node is not an immediate child of this tree");
  }
};
